use crate::event::EffectType;
use crate::event::Event;
use crate::event::RawEvent;
use std::path::PathBuf;

#[derive(Clone, Copy)]
enum Continuation {
    Pending,
    Complete,
}

struct PartialPaths {
    path_names: PathBuf,
    associated: Option<PathBuf>,
    //event_group_id: u16,
    state: Continuation,
}

impl PartialPaths {
    fn new() -> Self {
        Self {
            path_names: PathBuf::new(),
            associated: None,
            //event_group_id: 0,
            state: Continuation::Pending,
        }
    }

    // If the group ID of the "next" event differs from whatever we stored
    // before, we'll clear out what we have and start a new group.
    // Group IDs are a bit of an insurance policy. Normally, all events are
    // terminal on the first non-continuation or non-association event.
    // Rarely, especially under heavy load when we don't have a chance to
    // drain the buffer before it fills it, events can be skipped.
    //
    // If the event is a continuation, we'll add the path_name to the list.
    //
    // If the event is an association, we'll begin associating all the upcoming
    // path names in the same group with what we have already stored for the event.
    // Associations are expected for rename-to or link-to events.
    fn continue_with(&mut self, event: &RawEvent) -> Option<Event> {
        /*
        if event.event_group_id != self.event_group_id {
            self.path_names.clear();
            self.associated = None;
            self.event_group_id = event.event_group_id;
        }
        */
        match EffectType::from(event.effect_type) {
            EffectType::Continuation => {
                let path_name = event.path_name_buf_to_str();
                match self.associated {
                    Some(ref mut associated) => associated.push(path_name),
                    None => self.path_names.push(path_name),
                }
                self.state = Continuation::Pending;
                None
            }
            EffectType::Association => {
                self.associated = Some(PathBuf::new());
                self.state = Continuation::Pending;
                None
            }
            terminal_effect_type => {
                let path_name = self.path_names.to_string_lossy().to_string();
                let associated = match self.associated {
                    Some(ref associated) => Some(associated.to_string_lossy().to_string()),
                    None => None,
                };
                self.path_names.clear();
                self.associated = None;
                self.state = Continuation::Complete;
                Some(Event {
                    path_name,
                    associated,
                    timestamp: event.timestamp,
                    pid: event.pid,
                    path_type: event.path_type.into(),
                    effect_type: terminal_effect_type,
                })
            }
        }
    }
}

pub(crate) fn accumulating_event_stream_proxy(
    tx: std::sync::mpsc::Sender<Event>,
) -> impl FnMut(&[u8]) -> i32 {
    let mut path_parsing_state = PartialPaths::new();
    move |data: &[u8]| {
        let event = match plain::from_bytes(data) {
            Ok(event) => event,
            // Big oops, unexpected event format, mismatch between BPF and Rust types
            Err(_) => return 1,
        };
        // Event paths may be sent in pieces. Accumulating them here...
        let event = path_parsing_state.continue_with(event);
        match event {
            // Holding back until we have something meaningful
            None => 0,
            // Sending them along when we do
            Some(complete_event) => {
                match tx.send(complete_event) {
                    Ok(_) => 0,
                    // If the receiver has not been dropped, of course.
                    Err(_) => 1,
                }
            }
        }
    }
}
